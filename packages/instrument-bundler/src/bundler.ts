import {
  InstrumentBundlerBuildError,
  InstrumentBundlerBuildValidationError,
  InstrumentBundlerError,
  InstrumentBundlerInputValidationError
} from './error.js';
import { resolvePlugin } from './plugin.js';
import { resolveIndexInput } from './resolve.js';
import { $BuildFailure } from './schema.js';
import { inferLoader } from './utils.js';
import esbuild from './vendor/esbuild.js';

import type { BundleOptions, BundlerInput } from './types.js';
import type { BuildResult } from './vendor/esbuild.js';

export class InstrumentBundler {
  async bundle({ inputs }: BundleOptions) {
    this.validateInputs(inputs);
    const index = resolveIndexInput(inputs);
    const result = await this.build({ index, inputs });
    const bundle = this.parseBuildResult(result);
    return this.transformBundle(bundle);
  }

  private async build({ index, inputs }: { index: BundlerInput; inputs: BundlerInput[] }) {
    let result: BuildResult;
    try {
      result = await esbuild.build({
        bundle: true,
        format: 'esm',
        keepNames: true,
        metafile: true,
        minify: false,
        outfile: 'bundle.js',
        platform: 'browser',
        plugins: [resolvePlugin({ inputs })],
        stdin: {
          contents: `import instrument from './${index.name}'; var __exports = instrument;`,
          loader: inferLoader(index.name)
        },
        target: 'es2022',
        treeShaking: false,
        write: false
      });
    } catch (err) {
      if (!(err instanceof InstrumentBundlerError)) {
        const parseResult = await $BuildFailure.safeParseAsync(err);
        if (parseResult.success) {
          throw InstrumentBundlerBuildError.fromBuildFailure(parseResult.data);
        }
      }
      throw err;
    }
    return result;
  }

  /**
   * Validates the bundle generated from ESBuild to ensure it conforms to the expected structure. I don't think
   * any of these conditions will ever happen, but if they do, it is better to throw here than at runtime.
   *
   * @param result - the bundle generated by esbuild
   * @returns the bundle extracted from the sole output file (as validated)
   */
  private parseBuildResult(result: BuildResult): string {
    const outputFileCount = result.outputFiles?.length;
    if (outputFileCount !== 1) {
      throw new InstrumentBundlerBuildValidationError(
        `Unexpected number of output files: expected '1', found '${outputFileCount}'`
      );
    }
    const exportsCount = result.metafile?.outputs['bundle.js'].exports.length;
    if (exportsCount !== 0) {
      throw new InstrumentBundlerBuildValidationError(
        `Unexpected number of exports in output file: expected '0', found '${exportsCount}'`
      );
    }
    const nonDynamicImportCount = result.metafile?.outputs['bundle.js'].imports.reduce((count, current) => {
      if (current.kind !== 'dynamic-import') {
        return count + 1;
      }
      return count;
    }, 0);
    if (nonDynamicImportCount !== 0) {
      throw new InstrumentBundlerBuildValidationError(
        `Unexpected number of non-dynamic imports in output file: expected '0', found '${nonDynamicImportCount}'`
      );
    }
    return result.outputFiles![0].text;
  }

  /**
   * Converts the bundle into an an immediately invoked function expression (IIFE) that returns the value of
   * a top-level variable '__exports'. The result is subject to tree shaking and minification.
   *
   * @param input - the bundle with no static imports and exports,
   * @returns the minified bundle wrapped in an IIFE
   */
  private async transformBundle(bundle: string) {
    bundle = `(async () => {
      ${bundle}
      return __exports;
    } )()`;
    const result = await esbuild.transform(bundle, {
      format: 'esm',
      minify: true,
      platform: 'browser',
      target: 'es2022',
      treeShaking: true
    });
    return result.code;
  }

  /**
   * Checks that the provided inputs contain at least one element, and that no input contains
   * illegal characters in it's name (i.e., it is a shallow, relative path)
   *
   * @param inputs - the inputs to be used to generate a bundle
   */
  private validateInputs(inputs: BundlerInput[]): void {
    if (inputs.length === 0) {
      throw new InstrumentBundlerInputValidationError('Received empty array for inputs');
    }
    for (let i = 0; i < inputs.length; i++) {
      const input = inputs[0];
      if (input.name.includes('/')) {
        throw new InstrumentBundlerInputValidationError(
          `Illegal character '/' in name '${input.name}' of input in position '${i}': expected shallow relative path (e.g., './foo.js')`
        );
      }
    }
  }
}
